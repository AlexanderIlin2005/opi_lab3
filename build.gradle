plugins {
    id 'java'
    id 'war'
    id 'distribution'
}

group = 'sasailin'
version = '1.0'

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

repositories {
    mavenCentral()
}



sourceSets {
    integrationTest {
        java {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
            srcDir file('src/integrationTest/java')
        }
        resources.srcDir file('src/integrationTest/resources')
    }
}

configurations {
    integrationTestImplementation.extendsFrom testImplementation
    integrationTestRuntimeOnly.extendsFrom testRuntimeOnly
}




// ===== Dependencies =====
dependencies {

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.2'

    integrationTestImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.1'
    integrationTestRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.1'

// Selenium
    integrationTestImplementation 'org.seleniumhq.selenium:selenium-java:4.8.3'

// WebDriverManager
    integrationTestImplementation 'io.github.bonigarcia:webdrivermanager:5.6.3'



    // DB & Backend
    testImplementation 'com.h2database:h2:2.2.224'
    compileOnly 'org.projectlombok:lombok:1.18.12'
    annotationProcessor 'org.projectlombok:lombok:1.18.12'
    compileOnly 'javax:javaee-api:8.0'
    implementation 'org.glassfish:javax.json:1.1.4'
    implementation 'commons-codec:commons-codec:1.11'
    implementation 'io.jsonwebtoken:jjwt:0.9.1'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.2'
    implementation 'javax.persistence:javax.persistence-api:2.2'
    implementation 'org.postgresql:postgresql:42.5.1'
    implementation 'org.hibernate:hibernate-core:5.4.20.Final'
    implementation 'org.hibernate.validator:hibernate-validator:6.1.6.Final'
}

// ===== Compilation =====
tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
    options.annotationProcessorGeneratedSourcesDirectory = file("$buildDir/generated/sources/annotationProcessor/java/main")
}

// ===== Testing =====
test {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
    }
    dependsOn compileJava
}





war {
    archiveFileName = 'lab4.war'
}


// =============== compile ================


tasks.register('compile') {
    group = 'build'
    dependsOn 'compileJavaTask'
}

task compileJavaTask {
    group = 'build'
    dependsOn 'compileJava'
}

// =============== build ================

tasks.register('build_') {
    group = 'build'
    dependsOn 'buildProject'
}

task buildProject {
    dependsOn compileJavaTask
    dependsOn war
    doLast {
        println '–ü—Ä–æ–µ–∫—Ç —Å–æ–±—Ä–∞–Ω –∏ —É–ø–∞–∫–æ–≤–∞–Ω.'
    }
}

// =============== clean ================
clean {
    doLast {
        delete rootProject.buildDir
        println '–û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.'
    }
}

// =============== test ================
test {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
    }
    dependsOn compileJavaTask
}

// =============== music ================
task music {
    dependsOn buildProject
    group = 'custom'
    description = '–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –º—É–∑—ã–∫–∏ –ø–æ—Å–ª–µ —Å–±–æ—Ä–∫–∏'
    doLast {
        println 'üéµ –ó–∞–≤–µ—Ä—à–µ–Ω–æ! –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –º—É–∑—ã–∫–∏...'
        def os = System.getProperty("os.name").toLowerCase()
        if (os.contains("windows")) {
            exec { commandLine 'cmd', '/c', 'start', 'music.mp3' }
        } else if (os.contains("mac")) {
            exec { commandLine 'open', 'music.mp3' }
        } else {
            exec { commandLine 'xdg-open', 'music.mp3' }
        }
    }
}

// =============== native2ascii ================
task native2asciiAll {
    group = 'conversion'
    description = '–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤—Å–µ—Ö JSON-—Ñ–∞–π–ª–æ–≤ –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ —Ñ–æ—Ä–º–∞—Ç ASCII –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.'

    def srcDir = file('src/main/angular/lab-app/src/assets/i18n')
    def destDir = file("$buildDir/native2ascii/i18n/")

    inputs.dir srcDir
    outputs.dir destDir

    doLast {
        destDir.mkdirs()

        fileTree(dir: srcDir, include: '*.json').each { File srcFile ->
            def destFileName = srcFile.name.replace('.json', '.properties')
            def destFile = new File(destDir, destFileName)

            println "–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è: ${srcFile.name} -> ${destFile.name}"

            exec {
                commandLine 'native2ascii', '-encoding', 'UTF-8', srcFile.absolutePath, destFile.absolutePath
            }
        }
    }
}


// =============== xml  ================
task xml {
    group = 'verification'
    description = '–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö XML —Ñ–∞–π–ª–æ–≤ –Ω–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å'
    doLast {
        fileTree(dir: 'src', include: '**/*.xml').each { File xmlFile ->
            println "–í–∞–ª–∏–¥–∞—Ü–∏—è: ${xmlFile}"
            try {
                def factory = javax.xml.parsers.DocumentBuilderFactory.newInstance()
                def builder = factory.newDocumentBuilder()
                builder.parse(xmlFile)
            } catch (Exception e) {
                println "‚ùå XML invalid: ${xmlFile}"
            }
        }
    }
}

// =============== 8) doc ================
task doc {
    dependsOn javadoc
    doLast {
        def manifestFile = file("$buildDir/tmp/MANIFEST.MF")
        manifestFile.parentFile.mkdirs()
        def files = fileTree('src').matching { include '**/*.java' }

        manifestFile.withWriter { writer ->
            files.each { f ->
                def relPath = project.relativePath(f)
                def md5 = f.bytes.encodeHex().toString().substring(0, 32)
                def sha1 = f.bytes.encodeHex().toString().substring(0, 40)
                writer.println("${relPath}-MD5: ${md5}")
                writer.println("${relPath}-SHA1: ${sha1}")


                println "${relPath}"
                println "  MD5 : ${md5}"
                println "  SHA1: ${sha1}"
            }
        }

        println 'MD5, SHA-1 –∏ Javadoc –¥–æ–±–∞–≤–ª–µ–Ω—ã.'
    }
}



// =============== scp ================
task scp {
    dependsOn buildProject
    doLast {
        println "–û—Ç–∫—Ä—ã–≤–∞—é —Ç–µ—Ä–º–∏–Ω–∞–ª –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ SCP..."

        commandLine 'open', '-a', 'Terminal', './scp_upload.sh'
    }
}



// =============== report ================
task report {
    dependsOn test
    doLast {
        def reportDir = file("reports/test-results")
        reportDir.mkdirs()

        copy {
            from "build/test-results/test"
            into reportDir
            include "TEST-*.xml"
        }

        def reportFiles = fileTree(reportDir).matching {
            include "TEST-*.xml"
        }

        if (reportFiles.size() == 0) {
            println "–ù–µ—Ç —Ñ–∞–π–ª–æ–≤ –æ—Ç—á–µ—Ç–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ git."
            return
        }

        exec {
            commandLine 'git', 'add', 'reports/test-results'
        }


        exec {
            commandLine 'git', 'commit', '-m', '–î–æ–±–∞–≤–ª–µ–Ω –æ—Ç—á–µ—Ç –æ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏–∏ —Ç–µ—Å—Ç–æ–≤'
            ignoreExitValue true
        }
        println "–û—Ç—á—ë—Ç—ã —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ git –∏–∑ –ø–∞–ø–∫–∏ ${reportDir}"
    }
}


// =============== 12) alt ================
task alt {
    doLast {
        def altSrc = file("$buildDir/altSrc")

        copy {
            from 'src/main/java'
            into altSrc
            include '**/*.java'
            filter { line ->
                line
                        .replaceAll('\\bMain\\b', 'MainAlt')           // –∑–∞–º–µ–Ω–∏–º –∏–º—è –∫–ª–∞—Å—Å–∞
                        .replaceAll('\\bmyVar\\b', 'myAltVar')         // –∑–∞–º–µ–Ω–∏–º –∏–º—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
            }
        }

        println '–°–æ–∑–¥–∞–Ω–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –≤–µ—Ä—Å–∏—è –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤.'
    }
}


task compileAlt(type: JavaCompile) {
    dependsOn alt
    source = file("$buildDir/altSrc")
    destinationDirectory = file("$buildDir/classes-alt")
    classpath = sourceSets.main.compileClasspath
}


task altJar(type: Jar) {
    dependsOn compileAlt
    archiveBaseName.set('alt')
    destinationDirectory.set(file("$buildDir/libs"))
    from compileAlt.destinationDirectory

}



// =============== history ================
task history {
    doLast {
        def success = false
        while (!success) {
            def result = exec {
                ignoreExitValue = true
                commandLine './gradlew', 'compileJava'
            }
            if (result.exitValue == 0) {
                println "‚úÖ –ù–∞–π–¥–µ–Ω–∞ —Ä–∞–±–æ—Ç–∞—é—â–∞—è –≤–µ—Ä—Å–∏—è."
                success = true
            } else {
                exec {
                    commandLine 'git', 'reset', '--hard', 'HEAD~1'
                }
                println "üîÅ –û—Ç–∫–∞—Ç –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â—É—é –≤–µ—Ä—Å–∏—é..."
            }
        }
    }
}

// =============== team ================
task team {
    doLast {
        def revisions = ['HEAD~1', 'HEAD~2', 'HEAD~3', 'HEAD~4']
        def availableRevisions = []


        revisions.each { rev ->
            def check = ['git', 'rev-parse', '--verify', rev].execute()
            check.waitFor()
            if (check.exitValue() == 0) {
                availableRevisions << rev
            } else {
                println "–ü—Ä–æ–ø—É—Å–∫–∞–µ–º ${rev} ‚Äî –∫–æ–º–º–∏—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"
            }
        }

        if (availableRevisions.isEmpty()) {
            println "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–º–∏—Ç–æ–≤ –¥–ª—è —Å–±–æ—Ä–∫–∏. –ó–∞–¥–∞—á–∞ team –∑–∞–≤–µ—Ä—à–µ–Ω–∞."
            return
        }


        file("teamBuilds").mkdirs()

        availableRevisions.eachWithIndex { rev, i ->
            def workDir = file("teamBuilds/worktree${i}")

            // –î–æ–±–∞–≤–ª—è–µ–º worktree –Ω–∞ –Ω—É–∂–Ω—É—é —Ä–µ–≤–∏–∑–∏—é
            exec { commandLine 'git', 'worktree', 'add', workDir.absolutePath, rev }

            try {

                exec {
                    workingDir workDir
                    commandLine './gradlew', 'build'
                }


                copy {
                    from "${workDir}/build/libs"
                    into "teamBuilds/rev${i + 1}"
                    include '*.jar'
                }
            } catch (Exception e) {
                println "–°–±–æ—Ä–∫–∞ –∏–ª–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –¥–ª—è ${rev}: ${e.message}"
            } finally {

                exec { commandLine 'git', 'worktree', 'remove', '--force', workDir.absolutePath }
            }
        }


        if (file("teamBuilds").listFiles().find { it.isDirectory() && it.name.startsWith("rev") }) {
            ant.zip(destfile: "teamBuilds/team.zip", basedir: "teamBuilds") {
                fileset(dir: "teamBuilds") {
                    exclude name: "worktree*/**"
                    exclude name: "team.zip"
                }
            }

            println "–°–æ–∑–¥–∞–Ω zip-–∞—Ä—Ö–∏–≤ team.zip —Å ${availableRevisions.size()} —Ä–µ–≤–∏–∑–∏—è–º–∏."
        } else {
            println "–ù–µ—á–µ–≥–æ –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞—Ç—å ‚Äî —Å–±–æ—Ä–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã."
        }
    }
}



// =============== diff ================
task diff {
    doLast {
        def paramFile = file("exclude_classes.txt").readLines()
        def diffOutput = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'diff', '--name-only'
            standardOutput = diffOutput
        }
        def changedFiles = diffOutput.toString().split('\n')
        if (changedFiles.every { f -> paramFile.every { !f.contains(it) } }) {
            exec { commandLine 'git', 'add', '.' }
            exec { commandLine 'git', 'commit', '-m', '–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∫–æ–º–º–∏—Ç –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π' }
        }
    }
}





task integrationTest(type: Test) {
    description = '–ó–∞–ø—É—Å–∫–∞–µ—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã —Å Selenium.'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter test

    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
    }
}

check.dependsOn integrationTest
